<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analysis Tool for Water Supply Management: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Analysis Tool for Water Supply Management<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">1st DA PROJECT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_graph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class to represent a graph.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8hpp_source.html">Graph.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f" id="r_ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4c72b8ac4d693c49800a4c7e273654f">Graph</a> ()</td></tr>
<tr class="memdesc:ae4c72b8ac4d693c49800a4c7e273654f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor of the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> class.  <br /></td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e0f62ab24147de8830a5aad8fe4a78" id="r_a06e0f62ab24147de8830a5aad8fe4a78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06e0f62ab24147de8830a5aad8fe4a78">Graph</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a06e0f62ab24147de8830a5aad8fe4a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor of the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> class.  <br /></td></tr>
<tr class="separator:a06e0f62ab24147de8830a5aad8fe4a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ad4731959e5bc8408b7338dc722bad" id="r_ab2ad4731959e5bc8408b7338dc722bad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ad4731959e5bc8408b7338dc722bad">read_file_reservoir</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:ab2ad4731959e5bc8408b7338dc722bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reservoirs-file reader function.  <br /></td></tr>
<tr class="separator:ab2ad4731959e5bc8408b7338dc722bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19777729027960400a90be6f2e7641f4" id="r_a19777729027960400a90be6f2e7641f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19777729027960400a90be6f2e7641f4">read_file_stations</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a19777729027960400a90be6f2e7641f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stations-file reader function.  <br /></td></tr>
<tr class="separator:a19777729027960400a90be6f2e7641f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16934320d8af047bbe26be4a22217a75" id="r_a16934320d8af047bbe26be4a22217a75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16934320d8af047bbe26be4a22217a75">read_file_cities</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a16934320d8af047bbe26be4a22217a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cities-file reader function.  <br /></td></tr>
<tr class="separator:a16934320d8af047bbe26be4a22217a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad66163cba01d81e0ddc8fa680d36a6" id="r_a6ad66163cba01d81e0ddc8fa680d36a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ad66163cba01d81e0ddc8fa680d36a6">read_file_pipes</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a6ad66163cba01d81e0ddc8fa680d36a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipes-file reader function.  <br /></td></tr>
<tr class="separator:a6ad66163cba01d81e0ddc8fa680d36a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5e0517e2979c54eebdafc2a9875e8f" id="r_abb5e0517e2979c54eebdafc2a9875e8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb5e0517e2979c54eebdafc2a9875e8f">getNumVertex</a> () const</td></tr>
<tr class="memdesc:abb5e0517e2979c54eebdafc2a9875e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the total number of vertices in the vertexSet member variable.  <br /></td></tr>
<tr class="separator:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c52a9ad8b37a03b7b3efedb6b04667" id="r_a45c52a9ad8b37a03b7b3efedb6b04667"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_location.html">Location</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c52a9ad8b37a03b7b3efedb6b04667">getVertexSet</a> () const</td></tr>
<tr class="memdesc:a45c52a9ad8b37a03b7b3efedb6b04667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the vertexSet member variable.  <br /></td></tr>
<tr class="separator:a45c52a9ad8b37a03b7b3efedb6b04667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3185f0523334fa6ad89004c824dd47c" id="r_ad3185f0523334fa6ad89004c824dd47c"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_reservoir.html">Reservoir</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3185f0523334fa6ad89004c824dd47c">getMapReservoirs</a> () const</td></tr>
<tr class="memdesc:ad3185f0523334fa6ad89004c824dd47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only overloaded getter for the mapReservoirs member variable.  <br /></td></tr>
<tr class="separator:ad3185f0523334fa6ad89004c824dd47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81dd96f54aab6bc3fd08b4f71f598d" id="r_aac81dd96f54aab6bc3fd08b4f71f598d"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_reservoir.html">Reservoir</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac81dd96f54aab6bc3fd08b4f71f598d">getMapReservoirs</a> ()</td></tr>
<tr class="memdesc:aac81dd96f54aab6bc3fd08b4f71f598d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write overloaded getter for the mapReservoirs member variable.  <br /></td></tr>
<tr class="separator:aac81dd96f54aab6bc3fd08b4f71f598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980507859f6892799104929df2134a5c" id="r_a980507859f6892799104929df2134a5c"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_pumping_station.html">PumpingStation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a980507859f6892799104929df2134a5c">getMapStations</a> () const</td></tr>
<tr class="memdesc:a980507859f6892799104929df2134a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only overloaded getter for the mapStations member variable.  <br /></td></tr>
<tr class="separator:a980507859f6892799104929df2134a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b79cfd5b1d665452434158ef9abf0" id="r_ab13b79cfd5b1d665452434158ef9abf0"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_pumping_station.html">PumpingStation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab13b79cfd5b1d665452434158ef9abf0">getMapStations</a> ()</td></tr>
<tr class="memdesc:ab13b79cfd5b1d665452434158ef9abf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write overloaded getter for the mapStations member variable.  <br /></td></tr>
<tr class="separator:ab13b79cfd5b1d665452434158ef9abf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f44d03796ac1d52aa093eecf994b57" id="r_a58f44d03796ac1d52aa093eecf994b57"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_city.html">City</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58f44d03796ac1d52aa093eecf994b57">getMapCities</a> () const</td></tr>
<tr class="memdesc:a58f44d03796ac1d52aa093eecf994b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only overloaded getter for the mapCities member variable.  <br /></td></tr>
<tr class="separator:a58f44d03796ac1d52aa093eecf994b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdbcf4592c97cf6d8932515224189d8" id="r_adfdbcf4592c97cf6d8932515224189d8"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_city.html">City</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdbcf4592c97cf6d8932515224189d8">getMapCities</a> ()</td></tr>
<tr class="memdesc:adfdbcf4592c97cf6d8932515224189d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write overloaded getter for the mapCities member variable.  <br /></td></tr>
<tr class="separator:adfdbcf4592c97cf6d8932515224189d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00f75d5790aac20eff3b693b1eb61e3" id="r_ad00f75d5790aac20eff3b693b1eb61e3"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_pipe.html">Pipe</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad00f75d5790aac20eff3b693b1eb61e3">getMapPipes</a> () const</td></tr>
<tr class="memdesc:ad00f75d5790aac20eff3b693b1eb61e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only overloaded getter for the mapPipes member variable.  <br /></td></tr>
<tr class="separator:ad00f75d5790aac20eff3b693b1eb61e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3d9591a2a53c33b09ada9fa1c21660" id="r_ade3d9591a2a53c33b09ada9fa1c21660"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_pipe.html">Pipe</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade3d9591a2a53c33b09ada9fa1c21660">getMapPipes</a> ()</td></tr>
<tr class="memdesc:ade3d9591a2a53c33b09ada9fa1c21660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write overloaded getter for the mapPipes member variable.  <br /></td></tr>
<tr class="separator:ade3d9591a2a53c33b09ada9fa1c21660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccb160ae590c082ada101b0774a4c90" id="r_a4ccb160ae590c082ada101b0774a4c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_location.html">Location</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ccb160ae590c082ada101b0774a4c90">findVertex</a> (const std::string &amp;in) const</td></tr>
<tr class="memdesc:a4ccb160ae590c082ada101b0774a4c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to find a vertex with a given content.  <br /></td></tr>
<tr class="separator:a4ccb160ae590c082ada101b0774a4c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eabb8b3759e7eaa7b2f55b03fc40f7" id="r_ae5eabb8b3759e7eaa7b2f55b03fc40f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5eabb8b3759e7eaa7b2f55b03fc40f7">addVertexReservoir</a> (const std::string &amp;name, const std::string &amp;municipality, int id, const std::string &amp;code, double maximumDelivery)</td></tr>
<tr class="memdesc:ae5eabb8b3759e7eaa7b2f55b03fc40f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex (of subclass <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a>) with a given content to the vertexSet and mapReservoirs member variables.  <br /></td></tr>
<tr class="separator:ae5eabb8b3759e7eaa7b2f55b03fc40f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b27897e29e9a5c4b6db4a19598e32f" id="r_a40b27897e29e9a5c4b6db4a19598e32f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40b27897e29e9a5c4b6db4a19598e32f">addVertexStation</a> (int id, const std::string &amp;code)</td></tr>
<tr class="memdesc:a40b27897e29e9a5c4b6db4a19598e32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex (of subclass Station) with a given content to the vertexSet and mapStation member variables.  <br /></td></tr>
<tr class="separator:a40b27897e29e9a5c4b6db4a19598e32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60bfa27ff5cdb308bb0c54604226055" id="r_aa60bfa27ff5cdb308bb0c54604226055"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa60bfa27ff5cdb308bb0c54604226055">addVertexCity</a> (const std::string &amp;name, int id, const std::string &amp;code, double demand, int population)</td></tr>
<tr class="memdesc:aa60bfa27ff5cdb308bb0c54604226055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex (of subclass <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a>) with a given content to the vertexSet and mapCities member variables.  <br /></td></tr>
<tr class="separator:aa60bfa27ff5cdb308bb0c54604226055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b9140e6a07d71e6e057dd4fb6d841e" id="r_ad5b9140e6a07d71e6e057dd4fb6d841e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5b9140e6a07d71e6e057dd4fb6d841e">removeVertex</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:ad5b9140e6a07d71e6e057dd4fb6d841e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a vertex with a given content from the graph, and all outgoing and incoming edges.  <br /></td></tr>
<tr class="separator:ad5b9140e6a07d71e6e057dd4fb6d841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130892f4e8a7a3570d0bd0cadd40119c" id="r_a130892f4e8a7a3570d0bd0cadd40119c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a130892f4e8a7a3570d0bd0cadd40119c">addEdge</a> (const std::string &amp;source, const std::string &amp;dest, double w)</td></tr>
<tr class="separator:a130892f4e8a7a3570d0bd0cadd40119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e4dba58104715ffc8f704828868c3e" id="r_a22e4dba58104715ffc8f704828868c3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22e4dba58104715ffc8f704828868c3e">removeEdge</a> (const std::string &amp;source, const std::string &amp;dest)</td></tr>
<tr class="memdesc:a22e4dba58104715ffc8f704828868c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an edge from the graph, identified by the source and destination contents.  <br /></td></tr>
<tr class="separator:a22e4dba58104715ffc8f704828868c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbadbd085ee3f432abcb20a33d6b8bd7" id="r_afbadbd085ee3f432abcb20a33d6b8bd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbadbd085ee3f432abcb20a33d6b8bd7">addBidirectionalEdge</a> (const std::string &amp;source, const std::string &amp;dest, double w)</td></tr>
<tr class="separator:afbadbd085ee3f432abcb20a33d6b8bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254a115bbd3e6a9ca66148dfc04f8d2b" id="r_a254a115bbd3e6a9ca66148dfc04f8d2b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b">getCitiesFlow</a> (bool allCities, const std::string &amp;oneCity=&quot;&quot;, const std::string &amp;removeR=&quot;&quot;)</td></tr>
<tr class="memdesc:a254a115bbd3e6a9ca66148dfc04f8d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its corresponding maximum flow value.  <br /></td></tr>
<tr class="separator:a254a115bbd3e6a9ca66148dfc04f8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa229bb2d5b242d5e082bc4600af1db84" id="r_aa229bb2d5b242d5e082bc4600af1db84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa229bb2d5b242d5e082bc4600af1db84">writeFileMaxFlow</a> ()</td></tr>
<tr class="memdesc:aa229bb2d5b242d5e082bc4600af1db84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that implements the 2nd part of exercise [T2.1] - File output.  <br /></td></tr>
<tr class="separator:aa229bb2d5b242d5e082bc4600af1db84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41536de976f6a0410314633a3ad577f9" id="r_a41536de976f6a0410314633a3ad577f9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41536de976f6a0410314633a3ad577f9">verifyCityNeeds</a> ()</td></tr>
<tr class="memdesc:a41536de976f6a0410314633a3ad577f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that implements the features of exercise [T2.2].  <br /></td></tr>
<tr class="separator:a41536de976f6a0410314633a3ad577f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2d39cb3678f138d7d17d4203fa0a1e" id="r_a8e2d39cb3678f138d7d17d4203fa0a1e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e2d39cb3678f138d7d17d4203fa0a1e">removeReservoirCompare</a> (const std::string &amp;code)</td></tr>
<tr class="memdesc:a8e2d39cb3678f138d7d17d4203fa0a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that implements the 1st feature of exercise [T3.1].  <br /></td></tr>
<tr class="separator:a8e2d39cb3678f138d7d17d4203fa0a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fa1696d54d40ad3cef2850d0b9dade" id="r_a96fa1696d54d40ad3cef2850d0b9dade"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96fa1696d54d40ad3cef2850d0b9dade">removeStationsCompare</a> ()</td></tr>
<tr class="memdesc:a96fa1696d54d40ad3cef2850d0b9dade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that implements the feature of exercise [T3.2].  <br /></td></tr>
<tr class="separator:a96fa1696d54d40ad3cef2850d0b9dade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975bd6e5e71879591fa05c5be60c9242" id="r_a975bd6e5e71879591fa05c5be60c9242"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a975bd6e5e71879591fa05c5be60c9242">removeStationCompare</a> (const std::string &amp;code)</td></tr>
<tr class="memdesc:a975bd6e5e71879591fa05c5be60c9242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function for the implementation of the 1st feature of exercise [T3.2].  <br /></td></tr>
<tr class="separator:a975bd6e5e71879591fa05c5be60c9242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace5539c10b8402ab8a7ac2cb469613e" id="r_aace5539c10b8402ab8a7ac2cb469613e"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aace5539c10b8402ab8a7ac2cb469613e">removeAllPipesCompare</a> ()</td></tr>
<tr class="memdesc:aace5539c10b8402ab8a7ac2cb469613e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that implements the feature of exercise [T3.3].  <br /></td></tr>
<tr class="separator:aace5539c10b8402ab8a7ac2cb469613e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eee07e8908a184ccfc8c3c87e5a8f6" id="r_a27eee07e8908a184ccfc8c3c87e5a8f6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27eee07e8908a184ccfc8c3c87e5a8f6">removeMultiplePipesCompare</a> (const std::set&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;pipelines)</td></tr>
<tr class="memdesc:a27eee07e8908a184ccfc8c3c87e5a8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that implements an extra feature of exercise [T3.3].  <br /></td></tr>
<tr class="separator:a27eee07e8908a184ccfc8c3c87e5a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d9de557b310538b31a09ced23cb6e2" id="r_ae1d9de557b310538b31a09ced23cb6e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1d9de557b310538b31a09ced23cb6e2">removePipeCompare</a> (const std::string &amp;sourceCode, const std::string &amp;destCode)</td></tr>
<tr class="memdesc:ae1d9de557b310538b31a09ced23cb6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function for the implementation of the feature of exercise [T3.3].  <br /></td></tr>
<tr class="separator:ae1d9de557b310538b31a09ced23cb6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4beac67a2b51afef6b1d2777333ec3db" id="r_a4beac67a2b51afef6b1d2777333ec3db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4beac67a2b51afef6b1d2777333ec3db">findVertexIdx</a> (const std::string &amp;in) const</td></tr>
<tr class="memdesc:a4beac67a2b51afef6b1d2777333ec3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the vertex with a given content.  <br /></td></tr>
<tr class="separator:a4beac67a2b51afef6b1d2777333ec3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a9de7f3ae0f69f31a9c30c62905c5" id="r_a421a9de7f3ae0f69f31a9c30c62905c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a421a9de7f3ae0f69f31a9c30c62905c5">addR0C0</a> (const std::string &amp;toRemove=&quot;&quot;)</td></tr>
<tr class="memdesc:a421a9de7f3ae0f69f31a9c30c62905c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to add a Super-Source (<a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object which has code R_0) vertex and a Super-Sink (<a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> object which has code C_0) vertex, and their respective edges to a <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>.  <br /></td></tr>
<tr class="separator:a421a9de7f3ae0f69f31a9c30c62905c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7b4304579edaaf652ab8a10c0b97a0" id="r_a5f7b4304579edaaf652ab8a10c0b97a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f7b4304579edaaf652ab8a10c0b97a0">edmondsKarp</a> (const std::string &amp;source, const std::string &amp;target)</td></tr>
<tr class="memdesc:a5f7b4304579edaaf652ab8a10c0b97a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a>.  <br /></td></tr>
<tr class="separator:a5f7b4304579edaaf652ab8a10c0b97a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934b609ee2e637a1c16f39637e78e2a8" id="r_a934b609ee2e637a1c16f39637e78e2a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a934b609ee2e637a1c16f39637e78e2a8">findAugmentingPath</a> (<a class="el" href="class_location.html">Location</a> *s, <a class="el" href="class_location.html">Location</a> *t)</td></tr>
<tr class="memdesc:a934b609ee2e637a1c16f39637e78e2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to find an augmenting path using Breadth-First Search (BFS) - for <a class="el" href="#a5f7b4304579edaaf652ab8a10c0b97a0" title="Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for getCitiesFlow().">edmondsKarp()</a>.  <br /></td></tr>
<tr class="separator:a934b609ee2e637a1c16f39637e78e2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066150655d0a8e2791167e386c11ba6f" id="r_a066150655d0a8e2791167e386c11ba6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a066150655d0a8e2791167e386c11ba6f">testAndVisit</a> (std::queue&lt; <a class="el" href="class_location.html">Location</a> * &gt; &amp;q, <a class="el" href="class_pipe.html">Pipe</a> *e, <a class="el" href="class_location.html">Location</a> *w, double residual)</td></tr>
<tr class="memdesc:a066150655d0a8e2791167e386c11ba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to test the given vertex 'w' and visit it if conditions are met - for <a class="el" href="#a934b609ee2e637a1c16f39637e78e2a8" title="Auxiliary function to find an augmenting path using Breadth-First Search (BFS) - for edmondsKarp().">findAugmentingPath()</a>.  <br /></td></tr>
<tr class="separator:a066150655d0a8e2791167e386c11ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c7fb95869bf1a874b4b5b504c9c30e" id="r_a32c7fb95869bf1a874b4b5b504c9c30e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c7fb95869bf1a874b4b5b504c9c30e">findMinResidualAlongPath</a> (<a class="el" href="class_location.html">Location</a> *s, <a class="el" href="class_location.html">Location</a> *t)</td></tr>
<tr class="memdesc:a32c7fb95869bf1a874b4b5b504c9c30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to find the bottleneck - minimum residual capacity along the augmenting path.  <br /></td></tr>
<tr class="separator:a32c7fb95869bf1a874b4b5b504c9c30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e2eae542132c9ccda15946c2d7acb" id="r_a816e2eae542132c9ccda15946c2d7acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a816e2eae542132c9ccda15946c2d7acb">augmentFlowAlongPath</a> (<a class="el" href="class_location.html">Location</a> *s, <a class="el" href="class_location.html">Location</a> *t, double f)</td></tr>
<tr class="memdesc:a816e2eae542132c9ccda15946c2d7acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to augment flow along the augmenting path with the given flow value.  <br /></td></tr>
<tr class="separator:a816e2eae542132c9ccda15946c2d7acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adeb387f158068d1a596781bfb26d10e2" id="r_adeb387f158068d1a596781bfb26d10e2"><td class="memItemLeft" align="right" valign="top"><a id="adeb387f158068d1a596781bfb26d10e2" name="adeb387f158068d1a596781bfb26d10e2"></a>
std::vector&lt; <a class="el" href="class_location.html">Location</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexSet</b></td></tr>
<tr class="memdesc:adeb387f158068d1a596781bfb26d10e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member variable that stores all the vertices of a <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> object. <br /></td></tr>
<tr class="separator:adeb387f158068d1a596781bfb26d10e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926c8f21f67aec79c7ec03c5cfb141c3" id="r_a926c8f21f67aec79c7ec03c5cfb141c3"><td class="memItemLeft" align="right" valign="top"><a id="a926c8f21f67aec79c7ec03c5cfb141c3" name="a926c8f21f67aec79c7ec03c5cfb141c3"></a>
std::unordered_map&lt; std::string, <a class="el" href="class_reservoir.html">Reservoir</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mapReservoirs</b></td></tr>
<tr class="memdesc:a926c8f21f67aec79c7ec03c5cfb141c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table data structure that stores all <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> objects associated with their code for faster access. <br /></td></tr>
<tr class="separator:a926c8f21f67aec79c7ec03c5cfb141c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f673b593757276d39d86ceb868b0bbc" id="r_a3f673b593757276d39d86ceb868b0bbc"><td class="memItemLeft" align="right" valign="top"><a id="a3f673b593757276d39d86ceb868b0bbc" name="a3f673b593757276d39d86ceb868b0bbc"></a>
std::unordered_map&lt; std::string, <a class="el" href="class_pumping_station.html">PumpingStation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mapStations</b></td></tr>
<tr class="memdesc:a3f673b593757276d39d86ceb868b0bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table data structure that stores all <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> objects associated with their code for faster access. <br /></td></tr>
<tr class="separator:a3f673b593757276d39d86ceb868b0bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d47828804a376d6e7f29619154b8dee" id="r_a3d47828804a376d6e7f29619154b8dee"><td class="memItemLeft" align="right" valign="top"><a id="a3d47828804a376d6e7f29619154b8dee" name="a3d47828804a376d6e7f29619154b8dee"></a>
std::unordered_map&lt; std::string, <a class="el" href="class_city.html">City</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mapCities</b></td></tr>
<tr class="memdesc:a3d47828804a376d6e7f29619154b8dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table data structure that stores all <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects associated with their code for faster access. <br /></td></tr>
<tr class="separator:a3d47828804a376d6e7f29619154b8dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea081faf55895c9def5266025298bce1" id="r_aea081faf55895c9def5266025298bce1"><td class="memItemLeft" align="right" valign="top"><a id="aea081faf55895c9def5266025298bce1" name="aea081faf55895c9def5266025298bce1"></a>
std::unordered_map&lt; std::string, <a class="el" href="class_pipe.html">Pipe</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mapPipes</b></td></tr>
<tr class="memdesc:aea081faf55895c9def5266025298bce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table data structure that stores all <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> objects associated with the concatenation of the source and destination vertex's codes for faster access. <br /></td></tr>
<tr class="separator:aea081faf55895c9def5266025298bce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to represent a graph. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> </dd>
<dd>
<a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c72b8ac4d693c49800a4c7e273654f" name="ae4c72b8ac4d693c49800a4c7e273654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c72b8ac4d693c49800a4c7e273654f">&#9670;&#160;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor of the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> class. </p>
<p>Initializes the member variables with empty placeholders. </p><dl class="section note"><dt>Note</dt><dd>Time complexity: O(1). </dd></dl>

</div>
</div>
<a id="a06e0f62ab24147de8830a5aad8fe4a78" name="a06e0f62ab24147de8830a5aad8fe4a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e0f62ab24147de8830a5aad8fe4a78">&#9670;&#160;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor of the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> class. </p>
<p>Initializes the member variables with another <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> object's member variables. </p><dl class="section note"><dt>Note</dt><dd>Time complexity: O(1). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afbadbd085ee3f432abcb20a33d6b8bd7" name="afbadbd085ee3f432abcb20a33d6b8bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbadbd085ee3f432abcb20a33d6b8bd7">&#9670;&#160;</a></span>addBidirectionalEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a bidirectional edge to the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> (two <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> objects, one in each direction), given the contents of the source and destination vertices and the edge weight. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Code of the source <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a>. </td></tr>
    <tr><td class="paramname">dest</td><td>Code of the destination <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a>. </td></tr>
    <tr><td class="paramname">w</td><td>Max capacity of the new <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; <br  />
 false if the source or destination vertexes don't exist; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: same as <a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> -&gt; O(n), where n is the number of vertices in the vertexSet member variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> </dd>
<dd>
<a class="el" href="class_location.html#a02dc4788b24672ea68c316ab5dd991ff" title="Adds an outgoing edge (Pipe object) to the adj member variable.">Location::addEdge()</a> </dd>
<dd>
<a class="el" href="class_pipe.html#a76593ca627b8d8820cc4e9d02528a261" title="Sets the value of the reverse member variable.">Pipe::setReverse()</a> </dd></dl>

</div>
</div>
<a id="a130892f4e8a7a3570d0bd0cadd40119c" name="a130892f4e8a7a3570d0bd0cadd40119c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130892f4e8a7a3570d0bd0cadd40119c">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an edge to the graph, given the contents of the source and destination vertices, and the edge weight. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Code of the source <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a>. </td></tr>
    <tr><td class="paramname">dest</td><td>Code of the destination <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a>. </td></tr>
    <tr><td class="paramname">w</td><td>Max capacity of the new <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; <br  />
 false if the source or destination vertexes don't exist; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: same as <a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> -&gt; O(n), where n is the number of vertices in the vertexSet member variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> </dd>
<dd>
<a class="el" href="class_location.html#a02dc4788b24672ea68c316ab5dd991ff" title="Adds an outgoing edge (Pipe object) to the adj member variable.">Location::addEdge()</a> </dd></dl>

</div>
</div>
<a id="a421a9de7f3ae0f69f31a9c30c62905c5" name="a421a9de7f3ae0f69f31a9c30c62905c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421a9de7f3ae0f69f31a9c30c62905c5">&#9670;&#160;</a></span>addR0C0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addR0C0 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>toRemove</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function to add a Super-Source (<a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object which has code R_0) vertex and a Super-Sink (<a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> object which has code C_0) vertex, and their respective edges to a <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </p>
<p>In a flow-related problem: <br  />
 Super-Source connects itself through an edge - <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> object - to every "starting node" which are the <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> objects; <br  />
 Every "end node" - <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects - connects itself through an edge to a Super-Sink; <br  />
 The weight of the edges from the Super-Source to each <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object is the maximum delivery capacity of each <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a>; <br  />
 The weight of the edges from each <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> object to the Super-Sink is the demand of each <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a>; These special vertexes are created by function to be used by the <a class="el" href="#a5f7b4304579edaaf652ab8a10c0b97a0" title="Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for getCitiesFlow().">edmondsKarp()</a> algorithm; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toRemove</td><td>Code (content) of the <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object to be "removed" (flow from Super-Source to <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> set to 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O((n+p)*q), where: <br  />
<ul>
<li>n is the number of <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>; <br  />
</li>
<li>p is the number of <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>; <br  />
</li>
<li>q is the complexity of the <a class="el" href="#a130892f4e8a7a3570d0bd0cadd40119c">addEdge()</a> function; </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5f7b4304579edaaf652ab8a10c0b97a0" title="Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for getCitiesFlow().">edmondsKarp()</a> </dd>
<dd>
<a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> </dd>
<dd>
<a class="el" href="#a41536de976f6a0410314633a3ad577f9" title="Function that implements the features of exercise [T2.2].">verifyCityNeeds()</a> </dd></dl>

</div>
</div>
<a id="aa60bfa27ff5cdb308bb0c54604226055" name="aa60bfa27ff5cdb308bb0c54604226055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60bfa27ff5cdb308bb0c54604226055">&#9670;&#160;</a></span>addVertexCity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertexCity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>demand</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>population</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex (of subclass <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a>) with a given content to the vertexSet and mapCities member variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name,id,code,demand,population</td><td>All the information a <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> object should have. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; <br  />
 false if a vertex with that content already exists; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(1). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> </dd></dl>

</div>
</div>
<a id="ae5eabb8b3759e7eaa7b2f55b03fc40f7" name="ae5eabb8b3759e7eaa7b2f55b03fc40f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eabb8b3759e7eaa7b2f55b03fc40f7">&#9670;&#160;</a></span>addVertexReservoir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertexReservoir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>municipality</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maximumDelivery</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex (of subclass <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a>) with a given content to the vertexSet and mapReservoirs member variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name,municipality,id,code,maximumDelivery</td><td>All the information a <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object should have. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; <br  />
 false if a vertex with that content already exists; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(1). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> </dd></dl>

</div>
</div>
<a id="a40b27897e29e9a5c4b6db4a19598e32f" name="a40b27897e29e9a5c4b6db4a19598e32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b27897e29e9a5c4b6db4a19598e32f">&#9670;&#160;</a></span>addVertexStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertexStation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex (of subclass Station) with a given content to the vertexSet and mapStation member variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id,code</td><td>All the information a <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> object should have. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; <br  />
 false if a vertex with that content already exists; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(1). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> </dd></dl>

</div>
</div>
<a id="a816e2eae542132c9ccda15946c2d7acb" name="a816e2eae542132c9ccda15946c2d7acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816e2eae542132c9ccda15946c2d7acb">&#9670;&#160;</a></span>augmentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::augmentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_location.html">Location</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_location.html">Location</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function to augment flow along the augmenting path with the given flow value. </p>
<p>Traverses the augmenting path and updates the flow values accordingly, increasing the flow along forward edges (from the direction of s to t) and decreasing the flow along residual edges (from the direction of t to s). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Source <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex). </td></tr>
    <tr><td class="paramname">t</td><td>Target <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex). </td></tr>
    <tr><td class="paramname">f</td><td>Floating-point value representing the minimum residual capacity (bottleneck) in the augmenting path being analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n), where n is the number of edges in the augmenting path (at most E), where E is the number of edges in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>

</div>
</div>
<a id="a5f7b4304579edaaf652ab8a10c0b97a0" name="a5f7b4304579edaaf652ab8a10c0b97a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7b4304579edaaf652ab8a10c0b97a0">&#9670;&#160;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::edmondsKarp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a>. </p>
<p>It finds the MaxFlow in a flow network represented by a <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. It iteratively finds augmenting paths from the source to the target vertex, and augments the flow along these paths until no more augmenting paths exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Code (content) of the source <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex) </td></tr>
    <tr><td class="paramname">target</td><td>Code (content) of the target <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(V*E^2), where V is the number of vertices in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> and E is the number of edges. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a934b609ee2e637a1c16f39637e78e2a8" title="Auxiliary function to find an augmenting path using Breadth-First Search (BFS) - for edmondsKarp().">findAugmentingPath()</a> </dd>
<dd>
<a class="el" href="#a32c7fb95869bf1a874b4b5b504c9c30e" title="Auxiliary function to find the bottleneck - minimum residual capacity along the augmenting path.">findMinResidualAlongPath()</a> </dd>
<dd>
<a class="el" href="#a816e2eae542132c9ccda15946c2d7acb" title="Auxiliary function to augment flow along the augmenting path with the given flow value.">augmentFlowAlongPath()</a> </dd></dl>

</div>
</div>
<a id="a934b609ee2e637a1c16f39637e78e2a8" name="a934b609ee2e637a1c16f39637e78e2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934b609ee2e637a1c16f39637e78e2a8">&#9670;&#160;</a></span>findAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::findAugmentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_location.html">Location</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_location.html">Location</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function to find an augmenting path using Breadth-First Search (BFS) - for <a class="el" href="#a5f7b4304579edaaf652ab8a10c0b97a0" title="Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for getCitiesFlow().">edmondsKarp()</a>. </p>
<p>During the BFS traversal, for each outgoing and incoming edge, calls <a class="el" href="#a066150655d0a8e2791167e386c11ba6f" title="Auxiliary function to test the given vertex &#39;w&#39; and visit it if conditions are met - for findAugmenti...">testAndVisit()</a> to test their validity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Source <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex). </td></tr>
    <tr><td class="paramname">t</td><td>Target <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an augmenting path to the target is found, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(V+E), where V is the number of vertices in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> and E is the number of edges in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a066150655d0a8e2791167e386c11ba6f" title="Auxiliary function to test the given vertex &#39;w&#39; and visit it if conditions are met - for findAugmenti...">testAndVisit()</a> </dd></dl>

</div>
</div>
<a id="a32c7fb95869bf1a874b4b5b504c9c30e" name="a32c7fb95869bf1a874b4b5b504c9c30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c7fb95869bf1a874b4b5b504c9c30e">&#9670;&#160;</a></span>findMinResidualAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::findMinResidualAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_location.html">Location</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_location.html">Location</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function to find the bottleneck - minimum residual capacity along the augmenting path. </p>
<p>Traverses the augmenting path to find the minimum residual capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Source <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex). </td></tr>
    <tr><td class="paramname">t</td><td>Target <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating-point value representing the bottleneck of that augmenting path. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n), where n is the number of edges in the augmenting path (at most E-1), where E is the number of edges in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>

</div>
</div>
<a id="a4ccb160ae590c082ada101b0774a4c90" name="a4ccb160ae590c082ada101b0774a4c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccb160ae590c082ada101b0774a4c90">&#9670;&#160;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_location.html">Location</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function to find a vertex with a given content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Code (content) of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the vertex if found, and nullptr otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n), where n is the number of vertices in the vertexSet member variable. </dd></dl>

</div>
</div>
<a id="a4beac67a2b51afef6b1d2777333ec3db" name="a4beac67a2b51afef6b1d2777333ec3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beac67a2b51afef6b1d2777333ec3db">&#9670;&#160;</a></span>findVertexIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::findVertexIdx </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the vertex with a given content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Code (content) of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n), where n is the number of vertices in the vertexSet member variable. </dd></dl>

</div>
</div>
<a id="a254a115bbd3e6a9ca66148dfc04f8d2b" name="a254a115bbd3e6a9ca66148dfc04f8d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254a115bbd3e6a9ca66148dfc04f8d2b">&#9670;&#160;</a></span>getCitiesFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; Graph::getCitiesFlow </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allCities</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>oneCity</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>removeR</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its corresponding maximum flow value. </p>
<p>Creates a copy of the original graph, to add a Super-Source and Super-Sink vertex temporarily (<a class="el" href="#a421a9de7f3ae0f69f31a9c30c62905c5" title="Auxiliary function to add a Super-Source (Reservoir object which has code R_0) vertex and a Super-Sin...">addR0C0()</a>). Runs edmondsKarp to find the MaxFlow of the graph. Prepares the output according to the input parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allCities</td><td>true - function should return the maximum flow values that reaches each city. <br  />
 false - function should return the maximum flow value that reaches city whose code is oneCity. </td></tr>
    <tr><td class="paramname">oneCity</td><td>Empty string if true is passed as the allCities argument. <br  />
 Code of the city we wish to know the maximum flow of, if false is passed as the allCities argument. </td></tr>
    <tr><td class="paramname">removeR</td><td>Code (content) of the <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object to be "removed" (flow from Super-Source to <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> set to 0) by the <a class="el" href="#a421a9de7f3ae0f69f31a9c30c62905c5" title="Auxiliary function to add a Super-Source (Reservoir object which has code R_0) vertex and a Super-Sin...">addR0C0()</a> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs that contain all information about each city. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n + p + q*(V+E)), where: <br  />
<ul>
<li>n is the complexity of <a class="el" href="#a421a9de7f3ae0f69f31a9c30c62905c5" title="Auxiliary function to add a Super-Source (Reservoir object which has code R_0) vertex and a Super-Sin...">addR0C0()</a>; <br  />
</li>
<li>p is the complexity of <a class="el" href="#a5f7b4304579edaaf652ab8a10c0b97a0" title="Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for getCitiesFlow().">edmondsKarp()</a>; <br  />
</li>
<li>q is the number of <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects (in the mapCities member variable); <br  />
</li>
<li>V is the number of vertices in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> and E is the number of edges in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>; </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#a421a9de7f3ae0f69f31a9c30c62905c5" title="Auxiliary function to add a Super-Source (Reservoir object which has code R_0) vertex and a Super-Sin...">addR0C0()</a> </dd>
<dd>
<a class="el" href="#a5f7b4304579edaaf652ab8a10c0b97a0" title="Auxiliary function implementing the Edmonds-Karp (EK) algorithm - for getCitiesFlow().">edmondsKarp()</a> </dd>
<dd>
<a class="el" href="#aa229bb2d5b242d5e082bc4600af1db84" title="Function that implements the 2nd part of exercise [T2.1] - File output.">writeFileMaxFlow()</a> for outputting the Max-Flow to a file. </dd></dl>

</div>
</div>
<a id="adfdbcf4592c97cf6d8932515224189d8" name="adfdbcf4592c97cf6d8932515224189d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdbcf4592c97cf6d8932515224189d8">&#9670;&#160;</a></span>getMapCities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_city.html">City</a> * &gt; &amp; Graph::getMapCities </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-write overloaded getter for the mapCities member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Modifiable reference to the mapCities data structure. </dd></dl>

</div>
</div>
<a id="a58f44d03796ac1d52aa093eecf994b57" name="a58f44d03796ac1d52aa093eecf994b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f44d03796ac1d52aa093eecf994b57">&#9670;&#160;</a></span>getMapCities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_city.html">City</a> * &gt; Graph::getMapCities </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only overloaded getter for the mapCities member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the mapCities data structure. </dd></dl>

</div>
</div>
<a id="ade3d9591a2a53c33b09ada9fa1c21660" name="ade3d9591a2a53c33b09ada9fa1c21660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3d9591a2a53c33b09ada9fa1c21660">&#9670;&#160;</a></span>getMapPipes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_pipe.html">Pipe</a> * &gt; &amp; Graph::getMapPipes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-write overloaded getter for the mapPipes member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Modifiable reference to the mapPipes data structure. </dd></dl>

</div>
</div>
<a id="ad00f75d5790aac20eff3b693b1eb61e3" name="ad00f75d5790aac20eff3b693b1eb61e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00f75d5790aac20eff3b693b1eb61e3">&#9670;&#160;</a></span>getMapPipes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_pipe.html">Pipe</a> * &gt; Graph::getMapPipes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only overloaded getter for the mapPipes member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the mapPipes data structure. </dd></dl>

</div>
</div>
<a id="aac81dd96f54aab6bc3fd08b4f71f598d" name="aac81dd96f54aab6bc3fd08b4f71f598d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac81dd96f54aab6bc3fd08b4f71f598d">&#9670;&#160;</a></span>getMapReservoirs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_reservoir.html">Reservoir</a> * &gt; &amp; Graph::getMapReservoirs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-write overloaded getter for the mapReservoirs member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Modifiable reference to the mapReservoirs data structure. </dd></dl>

</div>
</div>
<a id="ad3185f0523334fa6ad89004c824dd47c" name="ad3185f0523334fa6ad89004c824dd47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3185f0523334fa6ad89004c824dd47c">&#9670;&#160;</a></span>getMapReservoirs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_reservoir.html">Reservoir</a> * &gt; Graph::getMapReservoirs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only overloaded getter for the mapReservoirs member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the mapReservoirs data structure. </dd></dl>

</div>
</div>
<a id="ab13b79cfd5b1d665452434158ef9abf0" name="ab13b79cfd5b1d665452434158ef9abf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13b79cfd5b1d665452434158ef9abf0">&#9670;&#160;</a></span>getMapStations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_pumping_station.html">PumpingStation</a> * &gt; &amp; Graph::getMapStations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-write overloaded getter for the mapStations member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Modifiable reference to the mapStations data structure. </dd></dl>

</div>
</div>
<a id="a980507859f6892799104929df2134a5c" name="a980507859f6892799104929df2134a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980507859f6892799104929df2134a5c">&#9670;&#160;</a></span>getMapStations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, <a class="el" href="class_pumping_station.html">PumpingStation</a> * &gt; Graph::getMapStations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only overloaded getter for the mapStations member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the mapStations data structure. </dd></dl>

</div>
</div>
<a id="abb5e0517e2979c54eebdafc2a9875e8f" name="abb5e0517e2979c54eebdafc2a9875e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5e0517e2979c54eebdafc2a9875e8f">&#9670;&#160;</a></span>getNumVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getNumVertex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the total number of vertices in the vertexSet member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer with the number of vertices in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>

</div>
</div>
<a id="a45c52a9ad8b37a03b7b3efedb6b04667" name="a45c52a9ad8b37a03b7b3efedb6b04667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c52a9ad8b37a03b7b3efedb6b04667">&#9670;&#160;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_location.html">Location</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the vertexSet member variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector with all the vertices in the graph. </dd></dl>

</div>
</div>
<a id="a16934320d8af047bbe26be4a22217a75" name="a16934320d8af047bbe26be4a22217a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16934320d8af047bbe26be4a22217a75">&#9670;&#160;</a></span>read_file_cities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::read_file_cities </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cities-file reader function. </p>
<p>Initializes part of the vertexSet member variable and the respective unordered_map with the pointers to the <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects, by reading them from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>String containing the path to the .csv file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was parsed correctly; <br  />
 false, if the file wasn't opened correctly; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n*p), where n is the number lines in the flights.csv file and p is the complexity of unordered_map::find() method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a40b27897e29e9a5c4b6db4a19598e32f" title="Adds a vertex (of subclass Station) with a given content to the vertexSet and mapStation member varia...">addVertexStation()</a> </dd></dl>

</div>
</div>
<a id="a6ad66163cba01d81e0ddc8fa680d36a6" name="a6ad66163cba01d81e0ddc8fa680d36a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad66163cba01d81e0ddc8fa680d36a6">&#9670;&#160;</a></span>read_file_pipes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::read_file_pipes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipes-file reader function. </p>
<p>Initializes the respective map, and the adj member variable of each <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object in the vertexSet with pointers to <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> objects, by reading them from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>String containing the path to the .csv file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was parsed correctly; <br  />
 false, if the file wasn't opened correctly; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n*p), where: <br  />
<ul>
<li>n is the number lines in the flights.csv file; <br  />
</li>
<li>p is the complexity of either the <a class="el" href="#a130892f4e8a7a3570d0bd0cadd40119c">addEdge()</a> or the <a class="el" href="#afbadbd085ee3f432abcb20a33d6b8bd7">addBidirectionalEdge()</a> functions, depending on if the edge is unidirectional or bidirectional; </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a130892f4e8a7a3570d0bd0cadd40119c">addEdge()</a> </dd>
<dd>
<a class="el" href="#afbadbd085ee3f432abcb20a33d6b8bd7">addBidirectionalEdge()</a> </dd></dl>

</div>
</div>
<a id="ab2ad4731959e5bc8408b7338dc722bad" name="ab2ad4731959e5bc8408b7338dc722bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ad4731959e5bc8408b7338dc722bad">&#9670;&#160;</a></span>read_file_reservoir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::read_file_reservoir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reservoirs-file reader function. </p>
<p>Initializes part of the vertexSet member variable and the respective unordered_map with the pointers to the <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> objects, by reading them from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>String containing the path to the .csv file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was parsed correctly; <br  />
 false, if the file wasn't opened correctly; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n*p), where n is the number lines in the flights.csv file and p is the complexity of unordered_map::find() method, that depends on the number of collisions, which a good hash function should minimize. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae5eabb8b3759e7eaa7b2f55b03fc40f7" title="Adds a vertex (of subclass Reservoir) with a given content to the vertexSet and mapReservoirs member ...">addVertexReservoir()</a> </dd></dl>

</div>
</div>
<a id="a19777729027960400a90be6f2e7641f4" name="a19777729027960400a90be6f2e7641f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19777729027960400a90be6f2e7641f4">&#9670;&#160;</a></span>read_file_stations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::read_file_stations </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stations-file reader function. </p>
<p>Initializes part of the vertexSet member variable and the respective unordered_map with the pointers to the <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> objects, by reading them from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>String containing the path to the .csv file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was parsed correctly; <br  />
 false, if the file wasn't opened correctly; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n*p), where n is the number lines in the flights.csv file and p is the complexity of unordered_map::find() method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a40b27897e29e9a5c4b6db4a19598e32f" title="Adds a vertex (of subclass Station) with a given content to the vertexSet and mapStation member varia...">addVertexStation()</a> </dd></dl>

</div>
</div>
<a id="aace5539c10b8402ab8a7ac2cb469613e" name="aace5539c10b8402ab8a7ac2cb469613e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace5539c10b8402ab8a7ac2cb469613e">&#9670;&#160;</a></span>removeAllPipesCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; &gt; Graph::removeAllPipesCompare </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that implements the feature of exercise [T3.3]. </p>
<p>For each <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>, calls the <a class="el" href="#ae1d9de557b310538b31a09ced23cb6e2" title="Auxiliary function for the implementation of the feature of exercise [T3.3].">removePipeCompare()</a> function to obtain the cities affected by its removal. </p><dl class="section return"><dt>Returns</dt><dd>Unordered Map that associates the code of each <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> removed (activated member variable set to false) with a vector with <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs for each city affected by said removal. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n*p), where n is the number of <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> and p is the complexity of <a class="el" href="#ae1d9de557b310538b31a09ced23cb6e2" title="Auxiliary function for the implementation of the feature of exercise [T3.3].">removePipeCompare()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#ae1d9de557b310538b31a09ced23cb6e2" title="Auxiliary function for the implementation of the feature of exercise [T3.3].">removePipeCompare()</a> </dd></dl>

</div>
</div>
<a id="a22e4dba58104715ffc8f704828868c3e" name="a22e4dba58104715ffc8f704828868c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e4dba58104715ffc8f704828868c3e">&#9670;&#160;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::removeEdge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an edge from the graph, identified by the source and destination contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source vertex's contents. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination vertex's contents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; false if such edge does not exist; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n+p), where n is the complexity of <a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> and p is the complexity of <a class="el" href="class_location.html#a27aa37bc92c6ffd08bc11138073a3c7b" title="Auxiliary function to remove an outgoing edge - that goes from the vertex that calls this function to...">Location::removeEdge()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ccb160ae590c082ada101b0774a4c90" title="Auxiliary function to find a vertex with a given content.">findVertex()</a> </dd>
<dd>
<a class="el" href="class_location.html#a27aa37bc92c6ffd08bc11138073a3c7b" title="Auxiliary function to remove an outgoing edge - that goes from the vertex that calls this function to...">Location::removeEdge()</a> </dd></dl>

</div>
</div>
<a id="a27eee07e8908a184ccfc8c3c87e5a8f6" name="a27eee07e8908a184ccfc8c3c87e5a8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27eee07e8908a184ccfc8c3c87e5a8f6">&#9670;&#160;</a></span>removeMultiplePipesCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; Graph::removeMultiplePipesCompare </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pipelines</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that implements an extra feature of exercise [T3.3]. </p>
<p>For each <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> in the input (found by their source and destination codes - in each pair of the set), calls <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> with those Pipes removed (activated member variable set to false) and stores the new totalFlow of each city. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelines</td><td>Set (to avoid duplicate Pipeline objects) of pairs with the source and destination <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> codes of each pipeline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs for each city affected by the removal of the multiple <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> objects. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n+p+q), where: <br  />
<ul>
<li>n is the complexity of <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a>; <br  />
</li>
<li>p is the number of <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>; <br  />
</li>
<li>q is the number of Pipelines to be removed; </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> </dd></dl>

</div>
</div>
<a id="ae1d9de557b310538b31a09ced23cb6e2" name="ae1d9de557b310538b31a09ced23cb6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d9de557b310538b31a09ced23cb6e2">&#9670;&#160;</a></span>removePipeCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; Graph::removePipeCompare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceCode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>destCode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function for the implementation of the feature of exercise [T3.3]. </p>
<p>Given the codes of the source and destination, calls <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> on a <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> copy with that <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> removed (activated member variable set to false) and stores the new totalFlow of each city. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceCode</td><td>Code (content) of the <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a>'s source (<a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object). </td></tr>
    <tr><td class="paramname">destCode</td><td>Code (content) of the <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a>'s destination (<a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs for each city affected by the removal of the <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n+p), where n is the complexity of <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> and p is the number of <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> </dd></dl>

</div>
</div>
<a id="a8e2d39cb3678f138d7d17d4203fa0a1e" name="a8e2d39cb3678f138d7d17d4203fa0a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2d39cb3678f138d7d17d4203fa0a1e">&#9670;&#160;</a></span>removeReservoirCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; Graph::removeReservoirCompare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that implements the 1st feature of exercise [T3.1]. </p>
<p>Given a <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object code, calls <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> on a <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> copy with that <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> "removed" (flow from Super-Source set to 0) and stores the new totalFlow of each city. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Code (content) of the <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs for each city affected by the removal of the <a class="el" href="class_reservoir.html" title="Type of Location in a water supply network (Graph class).">Reservoir</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n+p), where n is the complexity of <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> and p is the number of <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> </dd></dl>

</div>
</div>
<a id="a975bd6e5e71879591fa05c5be60c9242" name="a975bd6e5e71879591fa05c5be60c9242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975bd6e5e71879591fa05c5be60c9242">&#9670;&#160;</a></span>removeStationCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; Graph::removeStationCompare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function for the implementation of the 1st feature of exercise [T3.2]. </p>
<p>Given a <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> object code, calls <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> on a <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> copy with that <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> removed and stores the new totalFlow of each city. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Code (content) of the <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs for each city affected by the removal of the <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n+p), where n is the complexity of <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> and p is the number of <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> </dd></dl>

</div>
</div>
<a id="a96fa1696d54d40ad3cef2850d0b9dade" name="a96fa1696d54d40ad3cef2850d0b9dade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fa1696d54d40ad3cef2850d0b9dade">&#9670;&#160;</a></span>removeStationsCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; &gt; Graph::removeStationsCompare </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that implements the feature of exercise [T3.2]. </p>
<p>For each <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>, calls the <a class="el" href="#a975bd6e5e71879591fa05c5be60c9242" title="Auxiliary function for the implementation of the 1st feature of exercise [T3.2].">removeStationCompare()</a> function to obtain the cities affected by its removal. </p><dl class="section return"><dt>Returns</dt><dd>Unordered Map that associates the code of each <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> removed with a vector with <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs for each city affected by said removal. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n*p), where n is the number of <a class="el" href="class_pumping_station.html" title="Type of Location in a water supply network (Graph class).">PumpingStation</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a> and p is the complexity of <a class="el" href="#a975bd6e5e71879591fa05c5be60c9242" title="Auxiliary function for the implementation of the 1st feature of exercise [T3.2].">removeStationCompare()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#a975bd6e5e71879591fa05c5be60c9242" title="Auxiliary function for the implementation of the 1st feature of exercise [T3.2].">removeStationCompare()</a> </dd></dl>

</div>
</div>
<a id="ad5b9140e6a07d71e6e057dd4fb6d841e" name="ad5b9140e6a07d71e6e057dd4fb6d841e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b9140e6a07d71e6e057dd4fb6d841e">&#9670;&#160;</a></span>removeVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::removeVertex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a vertex with a given content from the graph, and all outgoing and incoming edges. </p>
<p>Once it finds the vertex with content in, it calls removeOutgoingEdges() to remove all outgoing <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> objects, and <a class="el" href="#a22e4dba58104715ffc8f704828868c3e" title="Removes an edge from the graph, identified by the source and destination contents.">removeEdge()</a> for each vertex in the vertexSet to remove all incoming <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> objects to that vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Content of the vertex to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful; <br  />
 false if such vertex does not exist; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n + (p + n*q)), where: <br  />
<ul>
<li>n is the size of the vertexSet member variable; <br  />
</li>
<li>p is the complexity of the removeOutgoingEdges() function if the vertex is found, otherwise the function isn't called; <br  />
</li>
<li>q is the complexity of the <a class="el" href="#a22e4dba58104715ffc8f704828868c3e" title="Removes an edge from the graph, identified by the source and destination contents.">removeEdge()</a> function if the vertex is found, otherwise the function isn't called; </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_location.html#a0ec5d6416b42bdcaa16a2a5ca79301fb" title="Auxiliary function to remove all outgoing edges (Pipe object) from the adj member variable.">Location::removeOutgoingEdges()</a> </dd>
<dd>
<a class="el" href="#a22e4dba58104715ffc8f704828868c3e" title="Removes an edge from the graph, identified by the source and destination contents.">removeEdge()</a> </dd></dl>

</div>
</div>
<a id="a066150655d0a8e2791167e386c11ba6f" name="a066150655d0a8e2791167e386c11ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066150655d0a8e2791167e386c11ba6f">&#9670;&#160;</a></span>testAndVisit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::testAndVisit </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_location.html">Location</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pipe.html">Pipe</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_location.html">Location</a> *</td>          <td class="paramname"><span class="paramname"><em>w</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>residual</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function to test the given vertex 'w' and visit it if conditions are met - for <a class="el" href="#a934b609ee2e637a1c16f39637e78e2a8" title="Auxiliary function to find an augmenting path using Breadth-First Search (BFS) - for edmondsKarp().">findAugmentingPath()</a>. </p>
<p>If the vertex wasn't visited yet, the edge has residual capacity and it is activated, then that vertex can be part of the current augmenting path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Reference to BFS queue (from <a class="el" href="#a934b609ee2e637a1c16f39637e78e2a8" title="Auxiliary function to find an augmenting path using Breadth-First Search (BFS) - for edmondsKarp().">findAugmentingPath()</a> function), so that w can be enqueued, if valid. </td></tr>
    <tr><td class="paramname">e</td><td>Pointer to the <a class="el" href="class_pipe.html" title="Class for edges of a graph (Graph class).">Pipe</a> object being traversed, to check its residual capacity and its state (activated or deactivated). </td></tr>
    <tr><td class="paramname">w</td><td>Pointer to the neighboring <a class="el" href="class_location.html" title="Class for Locations of a water supply network (Graph class).">Location</a> object (vertex) during the BFS, to check if it's already been traversed through. </td></tr>
    <tr><td class="paramname">residual</td><td>Residual capacity of e: <br  />
<ul>
<li>For outgoing edges, it is the available capacity for additional flow (so it is the difference between the edge's maximum capacity and current flow); <br  />
</li>
<li>For incoming edges, it is the flow that is able to be decreased (so it is the edge's flow); </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(1). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a934b609ee2e637a1c16f39637e78e2a8" title="Auxiliary function to find an augmenting path using Breadth-First Search (BFS) - for edmondsKarp().">findAugmentingPath()</a> </dd></dl>

</div>
</div>
<a id="a41536de976f6a0410314633a3ad577f9" name="a41536de976f6a0410314633a3ad577f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41536de976f6a0410314633a3ad577f9">&#9670;&#160;</a></span>verifyCityNeeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_city_info.html">CityInfo</a> &gt; Graph::verifyCityNeeds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that implements the features of exercise [T2.2]. </p>
<p>Given the current <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>'s layout, checks if the total flow through each <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> is lower than its demand. </p><dl class="section return"><dt>Returns</dt><dd>Vector of <a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> structs that contain all information about the cities whose totalFlow doesn't meet the demand. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n+p), where n is the complexity of <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> and p is the number of <a class="el" href="class_city.html" title="Type of Location in a water supply network (Graph class).">City</a> objects in the <a class="el" href="class_graph.html" title="Class to represent a graph.">Graph</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_city_info.html" title="Struct to store information about City objects.">CityInfo</a> </dd>
<dd>
<a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> </dd></dl>

</div>
</div>
<a id="aa229bb2d5b242d5e082bc4600af1db84" name="aa229bb2d5b242d5e082bc4600af1db84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa229bb2d5b242d5e082bc4600af1db84">&#9670;&#160;</a></span>writeFileMaxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::writeFileMaxFlow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that implements the 2nd part of exercise [T2.1] - File output. </p>
<p>Writes to a file (edits or creates it) the maximum flow that reaches each city - received from calling <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if the information was outputted correctly to the file; <br  />
 false if the file wasn't opened correctly; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity: O(n+p), where n is the complexity of <a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> and p is the number of pairs returned by it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a254a115bbd3e6a9ca66148dfc04f8d2b" title="Function that implements the 1st part of exercise [T2.1] - Assignment of each city with its correspon...">getCitiesFlow()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/gui/Desktop/DA/src/<a class="el" href="_graph_8hpp_source.html">Graph.hpp</a></li>
<li>/home/gui/Desktop/DA/src/<b>Graph.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_graph.html">Graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
